<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swimmer Rescue – Dive Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
  #story-overlay.hidden{ display:none; } .z-40{ z-index:40; }
  :root, html, body, #game-container, canvas, #ui-container { filter: none !important; -webkit-filter: none !important; }

    body{
      font-family:'Press Start 2P',cursive;
      overflow:hidden;
      background-color:#87CEEB;
      overscroll-behavior:none;
    }
    canvas{
      background-color:#f0f8ff;
      display:block;
      touch-action:none;
    }
    .game-ui{ text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
  </style>
</head>
<body class="bg-sky-400 flex items-center justify-center h-screen">
  <div id="game-container" class="relative w-full h-full sm:h-auto sm:max-w-2xl sm:aspect-[4/3] bg-white sm:rounded-xl shadow-2xl overflow-hidden">
    <canvas id="gameCanvas"></canvas>

    <!-- UI -->
    <div id="ui-container" class="absolute top-0 left-0 w-full p-2 sm:p-4 flex justify-between items-center text-white game-ui text-xs sm:text-sm md:text-base">
    <canvas id="miniMap" width="180" height="120" class="absolute top-2 right-2 sm:top-4 sm:right-4 bg-black/40 rounded-md border border-white/40"></canvas>
      <div id="lives-display">LIVES: 5</div>
      <div id="score-display">SCORE: 0</div>
    </div>

    <!-- Menu -->
    <div id="menu-screen" class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center text-white text-center p-4">
      <h1 id="menu-title" class="text-3xl sm:text-5xl md:text-6xl font-bold mb-4">Swimmer Rescue – Dive Mode</h1>
      <div id="menu-text" class="text-sm sm:text-base md:text-lg space-y-1 mb-4 leading-relaxed">
        <p>Tap/Click/Space = Stroke Up</p>
        <p>Hold <b>Down/S</b> (desktop) or press the <b>bottom-half</b> (mobile) to <b>DIVE</b></p>
        <p>Rescue <span class="text-yellow-300">victims</span> • Avoid <span class="text-red-300">corrupt officials</span></p>
      </div>
      <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 sm:py-4 sm:px-8 rounded-lg text-xl sm:text-2xl shadow-lg transition duration-300 transform hover:scale-105">
        Start Game
      </button>
    </div>
  
    <!-- Story Overlay -->
    <div id="story-overlay" class="absolute inset-0 bg-black/70 text-white flex flex-col items-center justify-center text-center hidden z-40">
      <h2 id="story-title" class="text-2xl sm:text-3xl mb-2"></h2>
      <p id="story-text" class="max-w-md text-sm sm:text-base mb-4 px-4"></p>
      <button id="story-next" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
        Continue
      </button>
    </div>
</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

// ===== Swimmer Sprite Sheet (replace GIF) =====
// Place 'runngboy_sheet.png' in the same folder as Index.html
const swimmerSheet = new Image();
swimmerSheet.src = "runngboy_sheet.png";
const SWIMMER_SPRITE = { frameW: 263, frameH: 334, frames: 16, fps: 25 };
let lastTS = 0;      // requestAnimationFrame timestamp tracking
let dtSec = 0;       // delta time in seconds (used for sprite animation)
let swimAnimT = 0;   // animation time accumulator
// ===== End Sprite Sheet =====

// ===== Story System =====
const storyOverlay = document.getElementById('story-overlay');
const storyTitle = document.getElementById('story-title');
const storyText = document.getElementById('story-text');
const storyNext = document.getElementById('story-next');

const StoryFlags = {
  introShown: false,
  firstRescue: false,
  faunaSeen: false,
  midpointShown: false,
  debriefShown: false,
};

const StoryQueue = [];
function resetStory(){
  StoryFlags.introShown = false;
  StoryFlags.firstRescue = false;
  StoryFlags.faunaSeen = false;
  StoryFlags.midpointShown = false;
  StoryFlags.debriefShown = false;
  StoryQueue.length = 0;
  if(storyOverlay){ storyOverlay.classList.add('hidden'); }
}
let storyShowing = false;

function queueStory(title, text){
  StoryQueue.push({title, text});
  if(!storyShowing){
    showNextStory();
  }
}
function showNextStory(){
  if(StoryQueue.length === 0){
    storyShowing = false;
    storyOverlay.classList.add('hidden');
    if(gameState === 'story'){
      gameState = 'playing'; // resume gameplay after story
      gameLoop();
    }
    return;
  }
  const s = StoryQueue.shift();
  storyShowing = true;
  storyOverlay.classList.remove('hidden');
  storyTitle.textContent = s.title;
  storyText.textContent = s.text;
  if(gameState === 'playing'){
    gameState = 'story';
  }
}
storyNext.addEventListener('click', showNextStory);

// Intro sequence
function showIntro(){
  if(StoryFlags.introShown) return;
  StoryFlags.introShown = true;
  queueStory("Mission Brief",
    "Flood waters are rising across the city. Rescue as many people as you can. Avoid hazards—floating logs, live wires, and now… reptiles.");
  queueStory("Controls",
    "Stroke Up: click/tap/Space. Hold Down/S to dive. Float with the water. Watch the mini‑map on the top‑right.");
}

// Midpoint reminder
function midpointStory(){
  if(StoryFlags.midpointShown) return;
  StoryFlags.midpointShown = true;
  queueStory("Mid‑Mission Update", "Great progress. New victims are appearing deeper underwater. Conserve stamina and time your dives.");
}

// Fauna warning
function faunaWarning(){
  if(StoryFlags.faunaSeen) return;
  StoryFlags.faunaSeen = true;
  queueStory("Heads Up!", "Crocodiles and alligators have been sighted in the flood! Keep your distance—they are fast and unpredictable.");
}

// Debrief (shown on game over once)
function debriefStory(scoreVal){
  if(StoryFlags.debriefShown) return;
  StoryFlags.debriefShown = true;
  queueStory("Debrief",
    "Mission complete. You earned " + scoreVal + " points. Each rescue matters—review the mini‑map and plan your next route.");
}
// ===== End Story System =====


// ===== Mini-Map =====
const miniMap = document.getElementById('miniMap');
const mctx = miniMap.getContext('2d');
function drawMiniMap(){
  // Clear
  mctx.clearRect(0,0,miniMap.width, miniMap.height);
  // Background
  mctx.fillStyle = 'rgba(0,0,0,0.5)';
  mctx.fillRect(0,0,miniMap.width, miniMap.height);

  if(!canvas || !swimmer || !water || typeof water.level !== 'number') return;

  const sx = miniMap.width / canvas.width;
  const sy = miniMap.height / canvas.height;

  // Water
  mctx.fillStyle = 'rgba(0,120,200,0.6)';
  const waterY = (typeof water.level==='number' ? water.level : canvas.height) * sy;
  mctx.fillRect(0, waterY, miniMap.width, miniMap.height - waterY);

  // Entities
  if(Array.isArray(circles)){
    circles.forEach(e => {
      let color = '#ffcc00'; // victim
      if(e.type==='corrupt') color = '#ff4d4d';
      else if(e.type==='log') color = '#c58b54';
      else if(e.type==='heart') color = '#ff5bd1';
      else if(e.type==='crocodile') color = '#22ff22';
      else if(e.type==='alligator') color = '#00dd88';
      mctx.fillStyle = color;
      mctx.beginPath();
      mctx.arc(e.x * sx, e.y * sy, 2, 0, Math.PI*2);
      mctx.fill();
    });
  }

  // Swimmer
  mctx.fillStyle = '#00ffea';
  mctx.fillRect(swimmer.x * sx, swimmer.y * sy, Math.max(2, SWIMMER_PROPERTIES.width * sx), Math.max(2, SWIMMER_PROPERTIES.height * sy));

  // Border + label
  mctx.strokeStyle = 'rgba(255,255,255,0.7)';
  mctx.lineWidth = 1;
  mctx.strokeRect(0,0,miniMap.width, miniMap.height);
  mctx.fillStyle = 'rgba(255,255,255,0.7)';
  mctx.font = '8px monospace';
  mctx.fillText('MAP', 6, 12);
}
// ===== End Mini-Map =====

// ===== Fauna Hazards =====
function spawnCrocodile(x, y) {
  circles.push({ x, y, radius: 20, type: 'crocodile', vx: (Math.random()*2-1)*1.2, vy: 0 });
}
function spawnAlligator(x, y) {
  circles.push({ x, y, radius: 22, type: 'alligator', vx: (Math.random()*2-1)*1.0, vy: 0 });
}
// ===== End Fauna Hazards =====


    const gameContainer = document.getElementById('game-container');

    const menuScreen = document.getElementById('menu-screen');
    const menuTitle = document.getElementById('menu-title');
    const menuText  = document.getElementById('menu-text');
    const startButton = document.getElementById('start-button');
    const livesDisplay = document.getElementById('lives-display');
    const scoreDisplay = document.getElementById('score-display');

    let swimmer, water, circles, lives, score, gameState, animationFrameId;
    let isDiving = false;

    // --- Constants ---
    const SWIMMER_PROPERTIES = {
      width: 10,
      height: 12,
      gravity: 0.22,
      lift: -5.5,
      bodyColor: '#FFD54F',
      headColor: '#F4D1A6',
      goggleColor: '#1E90FF',
      strapColor: '#143a52',
      capColor: '#2E86AB',
      maxJumps: 2
    };

    const WATER_PROPERTIES = {
      riseSpeed: 0.02,
      color: 'rgba(0,119,190,0.7)',
      waveHeight: 7,
      waveLength: 0.05
    };

    const ENTITY_PROPERTIES = {
      radius: 15,
      speed: 0.8,
      spawnRate: 95
    };

    let frameCount = 0;

    // ===== Parallax Background (Image-Based) =====
    // Upload these files alongside Index.html:
    // - Manila3 [Converted].png
    // - Manila6.png
    // If you rename them, update the src paths below.
    let bgLayers = [];
    const bgImgs = {
      far: new Image(),
      near: new Image()
    };
    // Use URL-encoded filename for the one with spaces/brackets
    bgImgs.far.src  = "Manila3%20%5BConverted%5D.png";
    bgImgs.near.src = "Manila6.png";

    // Road layer (repeat-x)
    const roadImg = new Image();
    roadImg.src = "BrickRoad.png";
    let roadY = null; // set in setupGame based on swimmer start
    let roadH = null;
    let roadOffset = 0;


    function initBackground(){
      // Align BOTH layers to the SAME "ground" baseline (bottom aligned).
      // You can adjust this to move the buildings up/down:
      const baselineY = Math.floor(canvas.height * 0.66);

      // Desired on-screen heights for each layer (tweak to taste)
      const farH  = Math.max(140, Math.floor(canvas.height * 0.35));
      const nearH = Math.max(180, Math.floor(canvas.height * 0.45));

      bgLayers = [
        { key:'far',  img:bgImgs.far,  baseY: baselineY, speed:0.10, offset:0, targetH: farH  },
        { key:'near', img:bgImgs.near, baseY: baselineY, speed:0.22, offset:0, targetH: nearH }
      ];
    }

    function drawParallaxBackground(){
      // Sky gradient base
      const grad = ctx.createLinearGradient(0,0,0,canvas.height);
      grad.addColorStop(0,'#8ED6FF');
      grad.addColorStop(1,'#D0F0FF');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Draw each parallax layer (repeat-x), bottoms aligned to baseY
      bgLayers.forEach(layer => {
        const img = layer.img;
        if(!img || !img.complete || img.naturalWidth === 0) return;

        const scale = layer.targetH / img.naturalHeight;
        const wScaled = img.naturalWidth * scale;
        const hScaled = img.naturalHeight * scale;

        // Bottom-align: y = baseline - scaledHeight
        const y = layer.baseY - hScaled;

        // Scroll
        layer.offset = (layer.offset - layer.speed * speedMultiplier);
        let ox = layer.offset % wScaled;
        if(ox > 0) ox -= wScaled;

        for(let x = ox; x < canvas.width; x += wScaled){
          ctx.drawImage(img, x, y, wScaled, hScaled);
        }
      });

      // Road strip aligned to swimmer start
      drawRoadLayer();
    }
    function drawRoadLayer(){
      if(roadY === null || roadH === null) return;
      if(!roadImg || !roadImg.complete || roadImg.naturalWidth === 0) return;

      // Scale road image to desired height
      const scale = roadH / roadImg.naturalHeight;
      const wScaled = roadImg.naturalWidth * scale;

      // Subtle parallax
      roadOffset = (roadOffset - 0.30 * speedMultiplier) % wScaled;
      let ox = roadOffset;
      if(ox > 0) ox -= wScaled;

      // Clip to road strip area
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, roadY, canvas.width, roadH);
      ctx.clip();

      for(let x = ox; x < canvas.width; x += wScaled){
        ctx.drawImage(roadImg, x, roadY, wScaled, roadH);
      }
      ctx.restore();
    }

    // ===== End Background =====

    function setupGame(){
        resetStory();
      lastTS = 0;
      dtSec = 0;
      swimAnimT = 0;
canvas.width  = gameContainer.clientWidth;
      canvas.height = gameContainer.clientHeight;
      initBackground();
      // Ensure water exists before any drawing
      water = {
        level: canvas.height * (1.0 - WATER_PROPERTIES.initialLevel),
        waveLength: WATER_PROPERTIES.waveLength,
        waveHeight: WATER_PROPERTIES.waveHeight
      };

      circles = [];
      for(let i=0;i<2;i++){ spawnCrocodile(Math.random()*canvas.width*0.8 + canvas.width*0.1, water.level - 10 - Math.random()*40); }
      for(let i=0;i<2;i++){ spawnAlligator(Math.random()*canvas.width*0.8 + canvas.width*0.1, water.level - 10 - Math.random()*40); }

      swimmer = {
        x: canvas.width/4,
        y: canvas.height/3,
        width: SWIMMER_PROPERTIES.width,
        height: SWIMMER_PROPERTIES.height,
        velocity: 0,
        gravity: SWIMMER_PROPERTIES.gravity,
        lift: SWIMMER_PROPERTIES.lift,
        jumpsLeft: SWIMMER_PROPERTIES.maxJumps
      };

      // Road aligned to swimmer start position
      roadH = Math.max(90, Math.floor(canvas.height * 0.22));
      roadY = Math.floor(swimmer.y + swimmer.height * 10.80);
      roadY = Math.max(0, Math.min(canvas.height - roadH, roadY));
      roadOffset = 0;


      // Higher starting water level
      water = { level: Math.floor(canvas.height * 0.7), riseSpeed: WATER_PROPERTIES.riseSpeed };

      circles = [];
      lives = 5;
      score = 0;
      frameCount = 0;
      gameState = 'start';
      isDiving = false;
      updateUI();
    }

    // --- Drawing ---
    function drawSwimmer(){
      const s = swimmer;
      // Torso
      ctx.fillStyle = SWIMMER_PROPERTIES.bodyColor;
      const torsoH = s.height*0.5;
      ctx.fillRect(s.x, s.y, s.width, torsoH);

      // Arms
      ctx.strokeStyle = SWIMMER_PROPERTIES.bodyColor;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(s.x+6, s.y+6);
      ctx.lineTo(s.x-12, s.y+10 + Math.sin(frameCount*0.2)*6);
      ctx.moveTo(s.x+s.width-6, s.y+6);
      ctx.lineTo(s.x+s.width+12, s.y+10 + Math.cos(frameCount*0.2)*6);
      ctx.stroke();

      // Head + cap
      const headX = s.x + s.width*0.5;
      const headY = s.y - 10;
      const r = 10;
      ctx.fillStyle = SWIMMER_PROPERTIES.capColor;
      ctx.beginPath(); ctx.arc(headX, headY, r, Math.PI, 0); ctx.closePath(); ctx.fill();
      ctx.fillStyle = SWIMMER_PROPERTIES.headColor;
      ctx.beginPath(); ctx.arc(headX, headY, r, 0, Math.PI); ctx.closePath(); ctx.fill();

      // Goggle strap
      ctx.strokeStyle = SWIMMER_PROPERTIES.strapColor;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(headX - r, headY - 2);
      ctx.lineTo(headX + r, headY - 2);
      ctx.stroke();

      // Goggles
      ctx.fillStyle = SWIMMER_PROPERTIES.goggleColor;
      ctx.beginPath();
      const gW=22, gH=6;
      const gx=headX-gW/2, gy=headY-gH/2;
      ctx.moveTo(gx+3,gy);
      ctx.lineTo(gx+gW-3,gy);
      ctx.quadraticCurveTo(gx+gW,gy,gx+gW,gy+3);
      ctx.lineTo(gx+gW,gy+gH-3);
      ctx.quadraticCurveTo(gx+gW,gy+gH,gx+gW-3,gy+gH);
      ctx.lineTo(gx+3,gy+gH);
      ctx.quadraticCurveTo(gx,gy+gH,gx,gy+gH-3);
      ctx.lineTo(gx,gy+3);
      ctx.quadraticCurveTo(gx,gy,gx+3,gy);
      ctx.closePath(); ctx.fill();

      // Legs
      ctx.strokeStyle = SWIMMER_PROPERTIES.bodyColor;
      ctx.lineWidth = 3;
      const kick = Math.sin(frameCount*0.2)*6;
      ctx.beginPath();
      ctx.moveTo(s.x+s.width*0.25, s.y+torsoH);
      ctx.lineTo(s.x+s.width*0.25, s.y+torsoH+10 + kick);
      ctx.moveTo(s.x+s.width*0.75, s.y+torsoH);
      ctx.lineTo(s.x+s.width*0.75, s.y+torsoH+10 - kick);
      ctx.stroke();

      // bubbles when diving
      if(isDiving){
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        for(let i=0;i<3;i++){
          const bx = s.x + s.width*0.2 + Math.random()*s.width*0.6;
          const by = s.y + torsoH + Math.random()*12;
          ctx.beginPath();
          ctx.arc(bx, by, 2 + Math.random()*2, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

// Draw swimmer using sprite sheet (better performance than GIF)
function drawSwimmerSprite(){
  if(!swimmerSheet || !swimmerSheet.complete) return;

  // advance animation using real time
  swimAnimT += dtSec;
  const frame = Math.floor(swimAnimT * SWIMMER_SPRITE.fps) % SWIMMER_SPRITE.frames;

  const sx = frame * SWIMMER_SPRITE.frameW;
  const sy = 0;

  // On-screen size (tweak these if you want the character bigger/smaller)
  const dw = 64;
  const dh = 64;

  const dx = swimmer.x + swimmer.width/2 - dw/2;
  const dy = swimmer.y + swimmer.height/2 - dh/2;

  ctx.drawImage(
    swimmerSheet,
    sx, sy, SWIMMER_SPRITE.frameW, SWIMMER_SPRITE.frameH,
    dx, dy, dw, dh
  );
}

    function drawWater(){
      if(!water || typeof water.level!=='number'){ return; }
      ctx.fillStyle = WATER_PROPERTIES.color;
      ctx.beginPath();
      ctx.moveTo(0, (water && typeof water.level==='number') ? water.level : canvas.height*0.6);
      for(let i=0;i<canvas.width;i++){
        ctx.lineTo(i, water.level + Math.sin(i*WATER_PROPERTIES.waveLength + frameCount*0.1)*WATER_PROPERTIES.waveHeight);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fill();
    }

    function drawVictim(e){
      const x=e.x, y=e.y;
      // splash
      ctx.strokeStyle='rgba(255,255,255,0.8)';
      ctx.lineWidth=2;
      ctx.beginPath();
      const rr=14 + Math.sin(frameCount*0.3)*2;
      ctx.arc(x, ((water && typeof water.level==='number') ? water.level : canvas.height*0.6)-2, rr, 0.2, Math.PI-0.2);
      ctx.stroke();
      // head
      ctx.fillStyle='#F4D1A6';
      ctx.beginPath(); ctx.arc(x, y-10, 8, 0, Math.PI*2); ctx.fill();
      // arms
      ctx.strokeStyle='#FFD54F';
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(x,y); ctx.lineTo(x-12, y-12 - Math.sin(frameCount*0.25)*5);
      ctx.moveTo(x,y); ctx.lineTo(x+12, y-12 - Math.cos(frameCount*0.25)*5);
      ctx.stroke();
      // torso
      ctx.fillStyle='#2E86AB';
      ctx.fillRect(x-5, y, 10, 12);
    }

    function drawCorrupt(e){
      const x=e.x, y=e.y;
      // ripple
      ctx.strokeStyle='rgba(255,255,255,0.6)';
      ctx.lineWidth=2;
      ctx.beginPath();
      const rr=12 + Math.sin(frameCount*0.25)*1.5;
      ctx.arc(x, (water && typeof water.level==='number') ? water.level : canvas.height*0.6, rr, 0.1, Math.PI-0.1);
      ctx.stroke();
      // suit
      ctx.fillStyle='#333'; ctx.fillRect(x-8, y, 16, 20);
      // head
      ctx.fillStyle='#e0c097'; ctx.beginPath(); ctx.arc(x, y-10, 8, 0, Math.PI*2); ctx.fill();
      // tie
      ctx.fillStyle='red'; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-4,y+12); ctx.lineTo(x+4,y+12); ctx.closePath(); ctx.fill();
      // briefcase
      ctx.fillStyle='#6b4a2f'; ctx.fillRect(x+10, y+6, 10, 8);
      ctx.fillStyle='#FFD700'; ctx.font='10px sans-serif'; ctx.fillText('₱', x+12, y+13);
    }

    
    function drawLog(e){
      const x = e.x, y = e.y;
      ctx.fillStyle = '#8B4513'; // brown log
      ctx.fillRect(x-15, y-5, 30, 10);
      ctx.strokeStyle = '#5A2D0C';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x-10, y, 5, 0, Math.PI*2);
      ctx.arc(x+10, y, 5, 0, Math.PI*2);
      ctx.stroke();
    }

    
    function drawHeart(e){
      const x = e.x, y = e.y;
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x-8, y-12, x-20, y+5, x, y+15);
      ctx.bezierCurveTo(x+20, y+5, x+8, y-12, x, y);
      ctx.fill();
      ctx.strokeStyle = '#660000';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    
    function drawCrocodile(e){
      const x=e.x, y=e.y;
      // body
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.ellipse(x, y, e.radius*1.3, e.radius*0.6, 0, 0, Math.PI*2);
      ctx.fill();
      // back ridges
      ctx.strokeStyle = '#004400';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=-3;i<=3;i++){
        ctx.moveTo(x + i*6, y-6);
        ctx.lineTo(x + i*6, y-12);
      }
      ctx.stroke();
      // eye
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(x+6, y-4, 2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000000';
      ctx.beginPath(); ctx.arc(x+6, y-4, 1, 0, Math.PI*2); ctx.fill();
    }

    function drawAlligator(e){
      const x=e.x, y=e.y;
      // body (darker green)
      ctx.fillStyle = '#116644';
      ctx.beginPath();
      ctx.ellipse(x, y, e.radius*1.4, e.radius*0.5, 0, 0, Math.PI*2);
      ctx.fill();
      // snout
      ctx.fillStyle = '#0c4f34';
      ctx.fillRect(x+6, y-4, 12, 8);
      // teeth
      ctx.fillStyle = '#ffffff';
      for(let i=0;i<4;i++){ ctx.fillRect(x+10+i*3, y+2, 1, 3); }
      // eye
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(x-4, y-4, 2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000000';
      ctx.beginPath(); ctx.arc(x-4, y-4, 1, 0, Math.PI*2); ctx.fill();
    }

    
    function drawColorTest(){
      const x=10, y=10, w=84, h=8;
      const cols=['#ff0000','#ffa500','#ffff00','#00ff00','#00ffff','#0000ff','#8b00ff'];
      for(let i=0;i<cols.length;i++){
        ctx.fillStyle = cols[i];
        ctx.fillRect(x + i*(w/cols.length), y, (w/cols.length)-1, h);
      }
    }

    function drawEntities(){
      circles.forEach(e => {
        if(e.type==='victim') drawVictim(e);
        else if(e.type==='crocodile'){ drawCrocodile(e); }
        else if(e.type==='alligator'){ drawAlligator(e); }
        else if(e.type==='corrupt') drawCorrupt(e);
        else if(e.type==='heart') drawHeart(e);
      });
    }

    
let speedMultiplier = 1;
function updateSpeed(){
  if(frameCount % (60*5) === 0){ // every ~5 seconds at 60fps
    speedMultiplier *= 1.02; // increase by 2%
  }
}

    // --- Updates ---
    function updateSwimmer(){
      swimmer.velocity += swimmer.gravity;
      if(isDiving){
        swimmer.velocity += swimmer.gravity * 0.7;
      }
      swimmer.y += swimmer.velocity;

      if(swimmer.y < 0){ swimmer.y = 0; swimmer.velocity = 0; }

      const surface = ((water && typeof water.level==='number') ? water.level : canvas.height*0.6) - swimmer.height * 0.6;

      if(!isDiving){
        if(swimmer.y > surface){
          swimmer.y = surface;
          swimmer.velocity = 0;
          swimmer.jumpsLeft = SWIMMER_PROPERTIES.maxJumps;
      if(swimmer.velocity < -2){
        swimmer.velocity = -0.5; // even more limited ascent speed
      }

        } else {
          swimmer.velocity += 0.005; // ultra slow rising after dive
        }
      } else {
        const maxDepth = Math.min(canvas.height - 40, ((water && typeof water.level==='number') ? water.level : canvas.height*0.6) + 80);
        if(swimmer.y > maxDepth){
          swimmer.y = maxDepth;
          swimmer.velocity = Math.min(0, swimmer.velocity);
        }
      }
    }

    function updateWater(){
      if(water && typeof water.level==='number' && water.level > 0){
        water.level -= WATER_PROPERTIES.riseSpeed;
      }
    }

    function spawnEntity(){
      if(frameCount % ENTITY_PROPERTIES.spawnRate === 0){
        const rand = Math.random();
        const isHeart = rand > 0.85;
        const isVictim = rand > 0.55;
        const isAlligator = rand < 0.2;
        const ySurf = ((water && typeof water.level==='number') ? water.level : canvas.height*0.6) - 16;
        const victimOffset = Math.random()*40; // some victims underwater
        const e = {
          x: canvas.width + ENTITY_PROPERTIES.radius,
          y: (isVictim ? (ySurf + victimOffset) : (ySurf + Math.random()*20)),
          radius: ENTITY_PROPERTIES.radius,
          type: isHeart ? 'heart' : (isAlligator ? 'alligator' : (isVictim ? 'victim' : 'corrupt'))
        };
        circles.push(e);
      }
    }

    function updateEntities(){
      if(Array.isArray(circles) && !StoryFlags.faunaSeen){ if(circles.some(e=>e.type==='crocodile' || e.type==='alligator')) faunaWarning(); }
      // drift fauna
      circles.forEach(e=>{ if(e.type==='crocodile' || e.type==='alligator'){ e.x += (e.vx||0); e.y += (e.vy||0); }});
      circles.forEach((e, idx) => {
        e.x -= ENTITY_PROPERTIES.speed * speedMultiplier;
        const distX = (swimmer.x + swimmer.width/2) - e.x;
        const distY = (swimmer.y + swimmer.height/2) - e.y;
        const distance = Math.hypot(distX, distY);
        const approxRadius = Math.max(swimmer.width, swimmer.height)*0.45;
        if(distance < approxRadius + e.radius){
          handleCollision(e, idx);
        }
        if(e.x < -e.radius){
          circles.splice(idx, 1);
        }
      });
    }

    function handleCollision(e, idx){
      if(e.type==='victim'){
        score++;
        water.level += 50;
        if(water && typeof water.level==='number' && water.level > canvas.height) water.level = canvas.height;
      } else if(e.type==='heart'){
        lives++;
      } else if(e.type==='log'){
        lives--;
      } else if(e.type==='corrupt'){
        lives--;
      }
      circles.splice(idx,1);
      updateUI();
    }

    function checkGameOver(){
      if(water && typeof water.level==='number' && water.level <= 0) gameState = 'gameOver';
      if(lives <= 0) gameState = 'gameOver';
    }

    function updateUI(){
      livesDisplay.textContent = `LIVES: ${lives}`;
      scoreDisplay.textContent = `SCORE: ${score}`;
    }

    function showGameOver(){
      cancelAnimationFrame(animationFrameId);
      menuTitle.textContent = 'Game Over';
      menuText.innerHTML = `Your final score is ${score}.<br/>Dive to rescue underwater victims • Avoid corrupt officials.`;
      startButton.textContent = 'Play Again';
      menuScreen.style.display = 'flex';
    }

    // --- Loop ---
    function gameLoop(ts = performance.now()){
      if(!lastTS) lastTS = ts;
      dtSec = Math.min(0.05, (ts - lastTS) / 1000);
      lastTS = ts;
      if(gameState!=='playing'){
        if(gameState==='gameOver'){ if(typeof score==='number') debriefStory(score); showGameOver(); }
        // Safety guard: if we're in 'story' but nothing to show, auto-start playing
        if(gameState==='story' && StoryQueue.length===0){
          gameState='playing';
          // fall through to continue loop
        } else {
          return;
        }
      }
ctx.clearRect(0,0,canvas.width,canvas.height);
      drawParallaxBackground();
      updateSwimmer();
      updateWater();
      spawnEntity();
      updateEntities();
      drawWater();
      drawSwimmerSprite();
      drawEntities();
      drawMiniMap();
      drawColorTest();
      checkGameOver();
      updateSpeed();
      if(typeof score==='number' && score>=50 && !StoryFlags.midpointShown){ midpointStory(); }
      frameCount++;
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Input ---
    function strokeUp(){
      if(gameState==='playing' && swimmer.jumpsLeft>0){
        swimmer.velocity = SWIMMER_PROPERTIES.lift;
        swimmer.jumpsLeft--;
      }
    }

    gameContainer.addEventListener('mousedown', (e)=>{
      if(e.button===0) strokeUp();
    });
    gameContainer.addEventListener('contextmenu', (e)=>e.preventDefault());

    // Touch: press bottom-half to dive, otherwise stroke
    gameContainer.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      const rect = gameContainer.getBoundingClientRect();
      const t = e.touches[0];
      if(t.clientY > rect.top + rect.height*0.6){
        isDiving = true;
      } else {
        strokeUp();
      }
    }, {passive:false});

    gameContainer.addEventListener('touchend', ()=>{ isDiving = false; });

    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space') strokeUp();
      if(e.code==='ArrowDown' || e.code==='KeyS') isDiving = true;
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code==='ArrowDown' || e.code==='KeyS') isDiving = false;
    });

    startButton.addEventListener('click', ()=>{
      showIntro();
      menuScreen.style.display = 'none';
      setupGame();
      gameState = 'story'; // pause into story first
      gameLoop();
    });

    window.addEventListener('resize', ()=>{
      const wasPlaying = gameState==='playing';
      cancelAnimationFrame(animationFrameId);
      setupGame();
      if(wasPlaying){ gameState='playing'; gameLoop(); }
      else{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawParallaxBackground(); drawWater(); drawSwimmerSprite(); drawMiniMap(); drawColorTest();
      }
    });

    window.onload = ()=>{
      setupGame();
      drawParallaxBackground();
      drawWater();
      drawSwimmerSprite();
    };
  </script>

<div id="error-log" style="position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 8px;font:12px monospace;z-index:9999;display:none"></div>
<script>
  (function(){
    const box = document.getElementById('error-log');
    function show(msg){
      if(!box) return;
      box.style.display='block';
      box.textContent = 'Error: ' + msg;
    }
    window.addEventListener('error', function(e){ show(e.message); });
    window.addEventListener('unhandledrejection', function(e){ show((e.reason && e.reason.message) || 'Promise rejected'); });
  })();
</script>
</body>
</html>
