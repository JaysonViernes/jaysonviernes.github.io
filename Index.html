<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swimmer Rescue – Dive Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body{
      font-family:'Press Start 2P',cursive;
      overflow:hidden;
      background-color:#87CEEB;
      overscroll-behavior:none;
    }
    canvas{
      background-color:#f0f8ff;
      display:block;
      touch-action:none;
    }
    .game-ui{ text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
  </style>
</head>
<body class="bg-sky-400 flex items-center justify-center h-screen">
  <div id="game-container" class="relative w-full h-full sm:h-auto sm:max-w-2xl sm:aspect-[4/3] bg-white sm:rounded-xl shadow-2xl overflow-hidden">
    <canvas id="gameCanvas"></canvas>

    <!-- UI -->
    <div id="ui-container" class="absolute top-0 left-0 w-full p-2 sm:p-4 flex justify-between items-center text-white game-ui text-xs sm:text-sm md:text-base">
      <div id="lives-display">LIVES: 5</div>
      <div id="score-display">SCORE: 0</div>
    </div>

    <!-- Menu -->
    <div id="menu-screen" class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center text-white text-center p-4">
      <h1 id="menu-title" class="text-3xl sm:text-5xl md:text-6xl font-bold mb-4">Swimmer Rescue – Dive Mode</h1>
      <div id="menu-text" class="text-sm sm:text-base md:text-lg space-y-1 mb-4 leading-relaxed">
        <p>Tap/Click/Space = Stroke Up</p>
        <p>Hold <b>Down/S</b> (desktop) or press the <b>bottom-half</b> (mobile) to <b>DIVE</b></p>
        <p>Rescue <span class="text-yellow-300">victims</span> • Avoid <span class="text-red-300">corrupt officials</span></p>
      </div>
      <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 sm:py-4 sm:px-8 rounded-lg text-xl sm:text-2xl shadow-lg transition duration-300 transform hover:scale-105">
        Start Game
      </button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');

    const menuScreen = document.getElementById('menu-screen');
    const menuTitle = document.getElementById('menu-title');
    const menuText  = document.getElementById('menu-text');
    const startButton = document.getElementById('start-button');
    const livesDisplay = document.getElementById('lives-display');
    const scoreDisplay = document.getElementById('score-display');

    let swimmer, water, circles, lives, score, gameState, animationFrameId;
    let isDiving = false;

    // --- Constants ---
    const SWIMMER_PROPERTIES = {
      width: 54,
      height: 34,
      gravity: 0.28,
      lift: -6.2,
      bodyColor: '#FFD54F',
      headColor: '#F4D1A6',
      goggleColor: '#1E90FF',
      strapColor: '#143a52',
      capColor: '#2E86AB',
      maxJumps: 2
    };

    const WATER_PROPERTIES = {
      riseSpeed: 0.12,
      color: 'rgba(0,119,190,0.7)',
      waveHeight: 7,
      waveLength: 0.05
    };

    const ENTITY_PROPERTIES = {
      radius: 15,
      speed: 2.6,
      spawnRate: 95
    };

    let frameCount = 0;

    // ===== Parallax Background =====
    let bgLayers = [];

    function createSkylinePattern(width, height){
      const off = document.createElement('canvas');
      off.width = width; off.height = height;
      const c = off.getContext('2d');
      const baseY = height * 0.9;
      const colors = ['#6b7b8c','#5e6d7c','#4f5d6a'];
      let x = 0;
      while(x < width){
        const w = 40 + Math.random()*80;
        const h = height*(0.25 + Math.random()*0.5);
        const y = baseY - h;
        const col = colors[Math.floor(Math.random()*colors.length)];
        c.fillStyle = col;
        c.fillRect(x,y,w,h);
        c.fillStyle = 'rgba(255,255,210,0.3)';
        const cols = Math.max(2, Math.floor(w/12));
        const rows = Math.max(2, Math.floor(h/20));
        for(let i=0;i<cols;i++){
          for(let j=0;j<rows;j++){
            if(Math.random()<0.15){
              const wx = x + 6 + i*(w/cols);
              const wy = y + 6 + j*(h/rows);
              c.fillRect(wx,wy,4,6);
            }
          }
        }
        if(Math.random()<0.25){
          c.strokeStyle = col;
          c.lineWidth = 2;
          c.beginPath();
          c.moveTo(x+w*0.5,y);
          c.lineTo(x+w*0.5,y - 10 - Math.random()*12);
          c.stroke();
        }
        x += w + 10;
      }
      return off;
    }

    function createHousesPattern(width, height){
      const off = document.createElement('canvas');
      off.width = width; off.height = height;
      const c = off.getContext('2d');
      const groundY = height * 0.95;
      c.fillStyle = '#8DBF87';
      c.fillRect(0,groundY-8,width,8);
      let x = 0;
      while(x < width){
        const houseW = 50 + Math.random()*30;
        const houseH = 30 + Math.random()*25;
        const y = groundY - houseH;
        c.fillStyle = '#c9a27a';
        c.fillRect(x,y,houseW,houseH);
        c.fillStyle = '#7a4f36';
        c.beginPath();
        c.moveTo(x-3,y);
        c.lineTo(x+houseW/2,y-12);
        c.lineTo(x+houseW+3,y);
        c.closePath();
        c.fill();
        c.fillStyle = '#6a3b28';
        c.fillRect(x+houseW*0.15, y+houseH-14, 8,14);
        c.fillStyle = '#eae3c8';
        c.fillRect(x+houseW*0.6, y+houseH*0.4, 10,8);

        if(Math.random()<0.7){
          const tx = x + houseW + 6;
          const th = 18 + Math.random()*10;
          c.fillStyle = '#5b7c4d';
          c.beginPath();
          c.arc(tx, groundY - th, 8, 0, Math.PI*2);
          c.fill();
          c.fillStyle = '#6b4a2f';
          c.fillRect(tx-2, groundY-10, 4,10);
        }
        x += houseW + 30;
      }
      return off;
    }

    function initBackground(){
      const W = Math.max(800, canvas.width);
      const H1 = Math.max(120, Math.floor(canvas.height*0.45));
      const H2 = Math.max(120, Math.floor(canvas.height*0.55));
      const skyline = createSkylinePattern(W,H1);
      const houses  = createHousesPattern(W,H2);
      bgLayers = [
        {img:skyline, y:canvas.height*0.25, speed:0.3, offset:0, height:H1},
        {img:houses,  y:canvas.height*0.55, speed:0.8, offset:0, height:H2}
      ];
    }

    function drawParallaxBackground(){
      const grad = ctx.createLinearGradient(0,0,0,canvas.height);
      grad.addColorStop(0,'#8ED6FF');
      grad.addColorStop(1,'#D0F0FF');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      bgLayers.forEach(layer=>{
        layer.offset = (layer.offset - layer.speed);
        const w = layer.img.width;
        let ox = layer.offset % w;
        if(ox > 0) ox -= w;
        for(let x = ox; x < canvas.width; x += w){
          ctx.drawImage(layer.img, x, layer.y, w, layer.height);
        }
      });
    }
    // ===== End Background =====

    function setupGame(){
      canvas.width  = gameContainer.clientWidth;
      canvas.height = gameContainer.clientHeight;
      initBackground();

      swimmer = {
        x: canvas.width/4,
        y: canvas.height/3,
        width: SWIMMER_PROPERTIES.width,
        height: SWIMMER_PROPERTIES.height,
        velocity: 0,
        gravity: SWIMMER_PROPERTIES.gravity,
        lift: SWIMMER_PROPERTIES.lift,
        jumpsLeft: SWIMMER_PROPERTIES.maxJumps
      };

      // Higher starting water level
      water = { level: Math.floor(canvas.height * 0.7), riseSpeed: WATER_PROPERTIES.riseSpeed };

      circles = [];
      lives = 5;
      score = 0;
      frameCount = 0;
      gameState = 'start';
      isDiving = false;
      updateUI();
    }

    // --- Drawing ---
    function drawSwimmer(){
      const s = swimmer;
      // Torso
      ctx.fillStyle = SWIMMER_PROPERTIES.bodyColor;
      const torsoH = s.height*0.5;
      ctx.fillRect(s.x, s.y, s.width, torsoH);

      // Arms
      ctx.strokeStyle = SWIMMER_PROPERTIES.bodyColor;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(s.x+6, s.y+6);
      ctx.lineTo(s.x-12, s.y+10 + Math.sin(frameCount*0.2)*6);
      ctx.moveTo(s.x+s.width-6, s.y+6);
      ctx.lineTo(s.x+s.width+12, s.y+10 + Math.cos(frameCount*0.2)*6);
      ctx.stroke();

      // Head + cap
      const headX = s.x + s.width*0.5;
      const headY = s.y - 10;
      const r = 10;
      ctx.fillStyle = SWIMMER_PROPERTIES.capColor;
      ctx.beginPath(); ctx.arc(headX, headY, r, Math.PI, 0); ctx.closePath(); ctx.fill();
      ctx.fillStyle = SWIMMER_PROPERTIES.headColor;
      ctx.beginPath(); ctx.arc(headX, headY, r, 0, Math.PI); ctx.closePath(); ctx.fill();

      // Goggle strap
      ctx.strokeStyle = SWIMMER_PROPERTIES.strapColor;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(headX - r, headY - 2);
      ctx.lineTo(headX + r, headY - 2);
      ctx.stroke();

      // Goggles
      ctx.fillStyle = SWIMMER_PROPERTIES.goggleColor;
      ctx.beginPath();
      const gW=22, gH=6;
      const gx=headX-gW/2, gy=headY-gH/2;
      ctx.moveTo(gx+3,gy);
      ctx.lineTo(gx+gW-3,gy);
      ctx.quadraticCurveTo(gx+gW,gy,gx+gW,gy+3);
      ctx.lineTo(gx+gW,gy+gH-3);
      ctx.quadraticCurveTo(gx+gW,gy+gH,gx+gW-3,gy+gH);
      ctx.lineTo(gx+3,gy+gH);
      ctx.quadraticCurveTo(gx,gy+gH,gx,gy+gH-3);
      ctx.lineTo(gx,gy+3);
      ctx.quadraticCurveTo(gx,gy,gx+3,gy);
      ctx.closePath(); ctx.fill();

      // Legs
      ctx.strokeStyle = SWIMMER_PROPERTIES.bodyColor;
      ctx.lineWidth = 3;
      const kick = Math.sin(frameCount*0.3)*6;
      ctx.beginPath();
      ctx.moveTo(s.x+s.width*0.25, s.y+torsoH);
      ctx.lineTo(s.x+s.width*0.25, s.y+torsoH+10 + kick);
      ctx.moveTo(s.x+s.width*0.75, s.y+torsoH);
      ctx.lineTo(s.x+s.width*0.75, s.y+torsoH+10 - kick);
      ctx.stroke();

      // bubbles when diving
      if(isDiving){
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        for(let i=0;i<3;i++){
          const bx = s.x + s.width*0.2 + Math.random()*s.width*0.6;
          const by = s.y + torsoH + Math.random()*12;
          ctx.beginPath();
          ctx.arc(bx, by, 2 + Math.random()*2, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function drawWater(){
      ctx.fillStyle = WATER_PROPERTIES.color;
      ctx.beginPath();
      ctx.moveTo(0, water.level);
      for(let i=0;i<canvas.width;i++){
        ctx.lineTo(i, water.level + Math.sin(i*WATER_PROPERTIES.waveLength + frameCount*0.1)*WATER_PROPERTIES.waveHeight);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fill();
    }

    function drawVictim(e){
      const x=e.x, y=e.y;
      // splash
      ctx.strokeStyle='rgba(255,255,255,0.8)';
      ctx.lineWidth=2;
      ctx.beginPath();
      const rr=14 + Math.sin(frameCount*0.3)*2;
      ctx.arc(x, water.level-2, rr, 0.2, Math.PI-0.2);
      ctx.stroke();
      // head
      ctx.fillStyle='#F4D1A6';
      ctx.beginPath(); ctx.arc(x, y-10, 8, 0, Math.PI*2); ctx.fill();
      // arms
      ctx.strokeStyle='#FFD54F';
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(x,y); ctx.lineTo(x-12, y-12 - Math.sin(frameCount*0.25)*5);
      ctx.moveTo(x,y); ctx.lineTo(x+12, y-12 - Math.cos(frameCount*0.25)*5);
      ctx.stroke();
      // torso
      ctx.fillStyle='#2E86AB';
      ctx.fillRect(x-5, y, 10, 12);
    }

    function drawCorrupt(e){
      const x=e.x, y=e.y;
      // ripple
      ctx.strokeStyle='rgba(255,255,255,0.6)';
      ctx.lineWidth=2;
      ctx.beginPath();
      const rr=12 + Math.sin(frameCount*0.25)*1.5;
      ctx.arc(x, water.level, rr, 0.1, Math.PI-0.1);
      ctx.stroke();
      // suit
      ctx.fillStyle='#333'; ctx.fillRect(x-8, y, 16, 20);
      // head
      ctx.fillStyle='#e0c097'; ctx.beginPath(); ctx.arc(x, y-10, 8, 0, Math.PI*2); ctx.fill();
      // tie
      ctx.fillStyle='red'; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-4,y+12); ctx.lineTo(x+4,y+12); ctx.closePath(); ctx.fill();
      // briefcase
      ctx.fillStyle='#6b4a2f'; ctx.fillRect(x+10, y+6, 10, 8);
      ctx.fillStyle='#FFD700'; ctx.font='10px sans-serif'; ctx.fillText('₱', x+12, y+13);
    }

    function drawEntities(){
      circles.forEach(e => {
        if(e.type==='victim') drawVictim(e);
        else if(e.type==='corrupt') drawCorrupt(e);
      });
    }

    // --- Updates ---
    function updateSwimmer(){
      swimmer.velocity += swimmer.gravity;
      if(isDiving){
        swimmer.velocity += swimmer.gravity * 0.7;
      }
      swimmer.y += swimmer.velocity;

      if(swimmer.y < 0){ swimmer.y = 0; swimmer.velocity = 0; }

      const surface = water.level - swimmer.height * 0.6;

      if(!isDiving){
        if(swimmer.y > surface){
          swimmer.y = surface;
          swimmer.velocity = 0;
          swimmer.jumpsLeft = SWIMMER_PROPERTIES.maxJumps;
        } else {
          swimmer.velocity += 0.06;
        }
      } else {
        const maxDepth = Math.min(canvas.height - 40, water.level + 80);
        if(swimmer.y > maxDepth){
          swimmer.y = maxDepth;
          swimmer.velocity = Math.min(0, swimmer.velocity);
        }
      }
    }

    function updateWater(){
      if(water.level > 0){
        water.level -= WATER_PROPERTIES.riseSpeed;
      }
    }

    function spawnEntity(){
      if(frameCount % ENTITY_PROPERTIES.spawnRate === 0){
        const isVictim = Math.random() > 0.55;
        const ySurf = water.level - 16;
        const victimOffset = Math.random()*40; // some victims underwater
        const e = {
          x: canvas.width + ENTITY_PROPERTIES.radius,
          y: (isVictim ? (ySurf + victimOffset) : (ySurf + Math.random()*20)),
          radius: ENTITY_PROPERTIES.radius,
          type: isVictim ? 'victim' : 'corrupt'
        };
        circles.push(e);
      }
    }

    function updateEntities(){
      circles.forEach((e, idx) => {
        e.x -= ENTITY_PROPERTIES.speed;
        const distX = (swimmer.x + swimmer.width/2) - e.x;
        const distY = (swimmer.y + swimmer.height/2) - e.y;
        const distance = Math.hypot(distX, distY);
        const approxRadius = Math.max(swimmer.width, swimmer.height)*0.45;
        if(distance < approxRadius + e.radius){
          handleCollision(e, idx);
        }
        if(e.x < -e.radius){
          circles.splice(idx, 1);
        }
      });
    }

    function handleCollision(e, idx){
      if(e.type==='victim'){
        score++;
        water.level += 50;
        if(water.level > canvas.height) water.level = canvas.height;
      } else if(e.type==='corrupt'){
        lives--;
      }
      circles.splice(idx,1);
      updateUI();
    }

    function checkGameOver(){
      if(water.level <= 0) gameState = 'gameOver';
      if(lives <= 0) gameState = 'gameOver';
    }

    function updateUI(){
      livesDisplay.textContent = `LIVES: ${lives}`;
      scoreDisplay.textContent = `SCORE: ${score}`;
    }

    function showGameOver(){
      cancelAnimationFrame(animationFrameId);
      menuTitle.textContent = 'Game Over';
      menuText.innerHTML = `Your final score is ${score}.<br/>Dive to rescue underwater victims • Avoid corrupt officials.`;
      startButton.textContent = 'Play Again';
      menuScreen.style.display = 'flex';
    }

    // --- Loop ---
    function gameLoop(){
      if(gameState!=='playing'){
        if(gameState==='gameOver') showGameOver();
        return;
      }
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawParallaxBackground();
      updateSwimmer();
      updateWater();
      spawnEntity();
      updateEntities();
      drawWater();
      drawSwimmer();
      drawEntities();
      checkGameOver();
      frameCount++;
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Input ---
    function strokeUp(){
      if(gameState==='playing' && swimmer.jumpsLeft>0){
        swimmer.velocity = SWIMMER_PROPERTIES.lift;
        swimmer.jumpsLeft--;
      }
    }

    gameContainer.addEventListener('mousedown', (e)=>{
      if(e.button===0) strokeUp();
    });
    gameContainer.addEventListener('contextmenu', (e)=>e.preventDefault());

    // Touch: press bottom-half to dive, otherwise stroke
    gameContainer.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      const rect = gameContainer.getBoundingClientRect();
      const t = e.touches[0];
      if(t.clientY > rect.top + rect.height*0.6){
        isDiving = true;
      } else {
        strokeUp();
      }
    }, {passive:false});

    gameContainer.addEventListener('touchend', ()=>{ isDiving = false; });

    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space') strokeUp();
      if(e.code==='ArrowDown' || e.code==='KeyS') isDiving = true;
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code==='ArrowDown' || e.code==='KeyS') isDiving = false;
    });

    startButton.addEventListener('click', ()=>{
      menuScreen.style.display = 'none';
      setupGame();
      gameState = 'playing';
      gameLoop();
    });

    window.addEventListener('resize', ()=>{
      const wasPlaying = gameState==='playing';
      cancelAnimationFrame(animationFrameId);
      setupGame();
      if(wasPlaying){ gameState='playing'; gameLoop(); }
      else{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawParallaxBackground(); drawWater(); drawSwimmer();
      }
    });

    window.onload = ()=>{
      setupGame();
      drawParallaxBackground();
      drawWater();
      drawSwimmer();
    };
  </script>
</body>
</html>
